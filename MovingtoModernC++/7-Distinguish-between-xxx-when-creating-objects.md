条款7:创建对象时使用()和{}的区别
===============================
在C++11中，你可以有多种语法选择用以对象的初始化，这样的语法显得混乱不堪并让人无所适从，括号，等号，大括号均可以用来进行初始化：
```
int x(0);	//使用()进行初始化
int y = 0;	//使用=进行初始化
int z{0};	//使用{}进行初始化
```
在很多情况下，可以同时使用等号和中括号
```
int z = {0};	//使用{}和=进行初始化
```
对于这一条，我通常的会忽略“等于-大括号”这种语法，因为C++通常认为它只有大括号。
认为这种语法"混乱不堪"的辩护者指出使用等号用于初始化会误导C++的初学者认为赋值动作已经发生了，而实际上并没有。对于内建类型例如int，这种区别只是理论上的，但是对于用户自定义类型，初始化和赋值的区别很重要，因为两者调用了不同的函数：
```
Widget w1;	//调用了构造函数
Widget w2 = w1;	//不是赋值语句，调用了拷贝构造函数
w1 = w2;	//赋值语句，调用了=操作符
```
尽管拥有多种初始化的语法，C++98在很多情况下无法实现想要的初始化。例如，很难直接判断当一个STL容器包含一些值集合(例如,1,3,5)的时候是否应该创建。
为了解决多种初始化语法冲突的问题，并且它们也无法涵盖所有的初始化场景，C++11引入了统一的初始化:使用单一的初始化语法，理论上可以在任何地方表达所有的初始化。它基于大括号，这也是我倾向于大括号初始化的原因。"统一的初始化"是一个概念，"大括号初始化"是一个语法实现。
大括号初始化使你可以实现以前不能表达的含义。使用大括号，指定容器初始值变得简单:
```
std::vector<int> v{1,3,5};//v的初始值是1,3,5
```
大括号也可以用来为非静态数据成员指定初始的默认值。C++11中的一项新语法是支持大括号像"="一样初始化，但是括号不行：
```
class Widget{
   ...
   private:
	int x{0};	//正确，x默认值为0
	int y = 0;	//正确
	int z(0);	//错误
}
```
另一方法，非拷贝对象(std:atomics-参考第40条)可以使用大括号和括号初始化，但是"="不行:
```
std::atomic<int> ai1{0};	//正确
std::atomic<int> ai2(0);	//正确
std::atomic<int> ai3 = 0;	//错误
```
因此很容易理解括号初始化被称为标准。在三种为C++初始化设计的表达式中，只有括号可以被用在任何地方。
括号初始化的一个新的特性是它禁止在基本类型中使用隐式的数值转换。如果一个括号中的表达式和初始化对象的类型不一致，代码将无法编译：
```
double x,y,z;
...
int sum1{x + y + z};	//错误，双精度类型数值相加无法表达为整形
使用括号和等号进行初始化时不会进行数值转换，因为这样会减少很多冗余的代码:
```
int sum2(x + y + z);	//正确，表达式的值为转换成整形
int sum3 = x + y + z;	//如上
```
括号初始化另外一个值得一提的特点是它摆脱了C++的令人头疼的歧义原则。C++原则的一个副作用是任何的可以用来申明的必须被解释成唯一的，经常困扰开发者的一个问题是他们想默认构造一个对象，但是常常自己申明了一个替代它的函数。根本的原因是你想调用一个带参数的构造函数，你可以这样做，
```
Widget w1(10);		//调用Widget的构造函数并传递参数10
```
但是如果你想使用类似语法调用一个无参的构造函数，实际上你申明了一个函数，而不是对象：
```
Widget w2();		//非常的歧义，定义了一个返回Widget对象的w2函数
```
函数申明不可能使用大括号传递参数列表，所有使用大括号默认构造函数不会带来这个问题：
```
Widget w3{};		//调用Widget无参构造函数
```
使用大括号进行初始化还有很多值得一提的地方。它的语法可以用于广泛的上下文语境之中，它可以防止隐式值转换，而且不会出现C++的二义性。这真实一举三得的好事。那么为什么这一条标题不是叫"优先使用大括号初始化的语法"呢?
大括号的初始化的缺点是它带来的一些令人意外的行为。这些行为来自使用大括号初始化 std::initializer_lists和重载构造函数的异常纠结的关系中。它们之间的相互关系使得代码开起来做了一样的事，实际上并不是。例如，条目2解释了当使用auto申明的变量使用大括号初始化时，它被推断为std::initializer_list类型，尽管其他的申明具有相同初始化变量的方法使得它的类型更为直观。造成的结果就是，你越喜欢使用auto，你就越没有使用大括号初始化的热情。
在构造函数调用中，只要不包含std::initializer_list参数列表，大括号和括号意义是一样：
```
class Widget{
public:
    Widget(int i,bool b);	//构造函数没有声明为std::initializer_list的参数
    Widget(int i,double d);	
}；
Widget w1(10,true);		//调用第一个构造函数
Widget w2(10,true);		//同样调用第一个构造函数
Widget w3(10,50);		//调用第二个构造函数
Widget w4(10,50);		//同样调用第二个构造函数
```
但是，如果有一个或多个构造函数的参数类型是std::initializer_list，使用大括号初始化语法会优先调用使用了参数类型std::initializer_list的构造函数。更明确的一点是，只要编译器一旦可以把一个使用大括号初始化解释成调用具有std::initializer_list参数的沟通函数，它一定会这么做。如果上面的Widget类具有一个带有std::initializer_list<long double>参数的构造函数，如下：
class Widget{
public:
   Widget(int i,bool b);	//和上面一样
   Widget(int i,double d);	//和上面一样
   Widget(std::initializer_list<long double> il); //新加的构造函数
   ...
};
```
w2和w4将会使新的构造函数创建，即使std::initializer_list参数的构造函数看起来比非std::initializer_list构造函数更难匹配,如下：
```
Widget w1(10,true);		//使用括号构造函数
Widget w2{10,true};		//使用大括号构造函数,调用std::initializer_list参数，10和true被转换成long dobule型
Widget w3(10,5,0);		//使用括号构造函数
Widget w4{10,5.0};		//使用大括号，调用std::initializer_list参数，10和5.0被转换为long double
```
即使通常复制和移动的构造也会被认为使用std::initializer_list构造函数:
```
class Widget{
public:
    Widget(int i,bool b);				//同上
    Widget(int i,double d);				//同上
    Widget(std::initializer_list<long double> il);	//同上

    operator float() const;				//转换成float型
    ...
};
Widget w5(w4);						//使用括号，调用拷贝构造函数
Widget w6(w4);						//使用大括号，调用std::initializer_list参数类型构造函数,w4被转换成float，然后再转换成long double
```