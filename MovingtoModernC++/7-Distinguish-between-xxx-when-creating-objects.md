条款7:创建对象时使用()和{}的区别
===============================
在C++11中，你可以有多种语法选择用以对象的初始化，这样的语法显得混乱不堪并让人无所适从，括号，等号，大括号均可以用来进行初始化：
```
int x(0);	//使用()进行初始化
int y = 0;	//使用=进行初始化
int z{0};	//使用{}进行初始化
```
在很多情况下，可以同时使用等号和中括号
```
int z = {0};	//使用{}和=进行初始化
```
对于这一条，我通常的会忽略“等于-大括号”这种语法，因为C++通常认为它只有大括号。
认为这种语法"混乱不堪"的辩护者指出使用等号用于初始化会误导C++的初学者认为赋值动作已经发生了，而实际上并没有。对于内建类型例如int，这种区别只是理论上的，但是对于用户自定义类型，初始化和赋值的区别很重要，因为两者调用了不同的函数：
```
Widget w1;	//调用了构造函数
Widget w2 = w1;	//不是赋值语句，调用了拷贝构造函数
w1 = w2;	//赋值语句，调用了=操作符
```
尽管拥有多种初始化的语法，C++98在很多情况下无法实现想要的初始化。例如，很难直接判断当一个STL容器包含一些值集合(例如,1,3,5)的时候是否应该创建。
为了解决多种初始化语法冲突的问题，并且它们也无法涵盖所有的初始化场景，C++11引入了统一的初始化:使用单一的初始化语法，理论上可以在任何地方表达所有的初始化。它基于大括号，这也是我倾向于大括号初始化的原因。"统一的初始化"是一个概念，"大括号初始化"是一个语法实现。
大括号初始化使你可以实现以前不能表达的含义。使用大括号，指定容器初始值变得简单:
```
std::vector<int> v{1,3,5};//v的初始值是1,3,5
```
大括号也可以用来为非静态数据成员指定初始的默认值。C++11中的一项新语法是支持大括号像"="一样初始化，但是括号不行：
```
class Widget{
   ...
   private:
	int x{0};	//正确，x默认值为0
	int y = 0;	//正确
	int z(0);	//错误
}
```
另一方法，非拷贝对象(std:atomics-参考第40条)可以使用大括号和括号初始化，但是"="不行:
```
std::atomic<int> ai1{0};	//正确
std::atomic<int> ai2(0);	//正确
std::atomic<int> ai3 = 0;	//错误
```
因此很容易理解括号初始化被称为标准。在三种为C++初始化设计的表达式中，只有括号可以被用在任何地方。
括号初始化的一个新的特性是它禁止在基本类型中使用隐式的数值转换。如果一个括号中的表达式和初始化对象的类型不一致，代码将无法编译：
```
double x,y,z;
...
int sum1{x + y + z};	//错误，双精度类型数值相加无法表达为整形
使用括号和等号进行初始化时不会进行数值转换，因为这样会减少很多冗余的代码:
```
int sum2(x + y + z);	//正确，表达式的值为转换成整形
int sum3 = x + y + z;	//如上
```
括号初始化另外一个值得一提的特点是它摆脱了C++的令人头疼的歧义原则。C++原则的一个副作用是任何的可以用来申明的必须被解释成唯一的，经常困扰开发者的一个问题是他们想默认构造一个对象，但是常常自己申明了一个替代它的函数。根本的原因是你想调用一个带参数的构造函数，你可以这样做，
```
Widget w1(10);		//调用Widget的构造函数并传递参数10
```
但是如果你想使用类似语法调用一个无参的构造函数，实际上你申明了一个函数，而不是对象：
```
Widget w2();		//非常的歧义，定义了一个返回Widget对象的w2函数
```
函数申明不可能使用大括号传递参数列表，所有使用大括号默认构造函数不会带来这个问题：
```
Widget w3{};		//调用Widget无参构造函数
```